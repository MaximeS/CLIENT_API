'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var rabbit = require('rabbit.js');
var _ = require('lodash');
var Cast = require('waterline/lib/waterline/core/typecast');

var PersistenceHandler = (function () {

  /**
   * Setup the persistence handler.
   *
   * note: this adapter should be able to function in the absence of
   * sails. However, we need to wait for the persistence adapter to load before
   * trying to persist payloads from the messaging queue. We check for the
   * existence of global.sails, and if it exists, wait for the orm hook to 
   * finish loading.
   *
   * corollary: in some ways, this trades one potential race condition for
   * another. The app might try to send messages to queues that aren't yet bound
   * to a persistence handler. This is an inconvenience, but not a dealbreaker.
   * Sending a message to a queue and having it stuck there is much better than
   * pulling a message off the queue and not be able to persist it anywhere.
   */

  function PersistenceHandler(connection, model) {
    var _this = this;

    _classCallCheck(this, PersistenceHandler);

    this.connection = connection;
    this.model = model;

    if (!this.isPersistentModel()) {
      throw new Error('model ' + this.model.identity + ' does not support persistence');
    }

    return this.model.getWorkerSocket({ name: 'persistence' }).then(function (socket) {
      _this.socket = socket;

      if (!global.sails) {
        console.log('sails-rabbitmq: binding persistence handlers immediately...');
        return _this.bindPersistenceHandler();
      }

      console.log('sails-rabbitmq: waiting for orm hook to load before binding persistence handlers...');
      global.sails.after('hook:orm:loaded', function () {
        _this.bindPersistenceHandler();
      });
    })['catch'](function (err) {
      console.error(err);
    });
  }

  _createClass(PersistenceHandler, [{
    key: 'teardown',

    /**
     * Release all sockets
     */
    value: function teardown() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.socket.once('close', function () {
          resolve();
        });
        _this2.socket.close();
      });
    }
  }, {
    key: 'bindPersistenceHandler',
    value: function bindPersistenceHandler() {
      var _this3 = this;

      var connectionId = this.model.getPersistenceConnection();
      var persistenceConnection = this.model.connections[connectionId]._adapter;

      this.socket.on('data', function (data) {
        var values = JSON.parse(data);
        var typecast = new Cast();
        typecast.initialize(_this3.model.attributes);
        values = typecast.run(values);
        var pk = values[_this3.model.primaryKey];

        if (pk) {
          persistenceConnection.update(connectionId, _this3.model.identity, { where: { id: pk } }, values, function (err, model) {
            if (!err) {
              _this3.model.publish(model);
            }
            _this3.socket.ack();
          });
        } else {
          persistenceConnection.create(connectionId, _this3.model.identity, values, function (err, model) {
            if (!err) {
              _this3.model.publish(model);
            }
            _this3.socket.ack();
          });
        }
      });
    }
  }, {
    key: 'isPersistentModel',

    /**
     * Return true if the specified model supports persistence; false otherwise
     */
    value: function isPersistentModel() {
      var connectionCount = this.model.connection.length;

      if (connectionCount > 2) {
        console.error('Persistent connection is ambiguous for model ' + this.model.identity);
      }

      return connectionCount === 2;
    }
  }]);

  return PersistenceHandler;
})();

exports['default'] = PersistenceHandler;
module.exports = exports['default'];